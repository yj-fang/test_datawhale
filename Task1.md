
##  数据分析(第二版)学习记录
### 第四章 NumPy基础：数组和矢量计算

#### 4.1 NumPy的ndarray: 一种多维数组对象


```python
import numpy as np
#生成随机数组
data = np.random.randn(2,3)
print(data)
```

    [[-1.04050957 -0.02706704  0.93513566]
     [ 0.69399011  0.20075967  0.93502242]]
    


```python
data* 10
```




    array([[-10.40509565,  -0.27067042,   9.35135661],
           [  6.93990112,   2.00759672,   9.35022421]])




```python
#数组大小与数据类型查看
data.shape
```




    (2, 3)




```python
data.dtype
```




    dtype('float64')



* 创建ndarray


```python
data1 = [6, 7.5, 8, 0, 1]
arr1 = np.array(data1)
print(arr1)
```

    [ 6.   7.5  8.   0.   1. ]
    


```python
data2 = [[1,2,3,4],[5,6,7,8]]
arr2 = np.array(data2)
arr2
```




    array([[1, 2, 3, 4],
           [5, 6, 7, 8]])




```python
arr1.dtype
```




    dtype('float64')




```python
arr2.dtype
```




    dtype('int32')



*** 特殊数组***


```python
np.zeros(10)
```




    array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])




```python
np.zeros((3,6))
```




    array([[ 0.,  0.,  0.,  0.,  0.,  0.],
           [ 0.,  0.,  0.,  0.,  0.,  0.],
           [ 0.,  0.,  0.,  0.,  0.,  0.]])




```python
np.empty((2,3,3))
```




    array([[[ 0.,  0.,  0.],
            [ 0.,  0.,  0.],
            [ 0.,  0.,  0.]],
    
           [[ 0.,  0.,  0.],
            [ 0.,  0.,  0.],
            [ 0.,  0.,  0.]]])



![特殊数组函数](./特殊数组函数.png)

* ndarray 的数据类型


```python
arr1 = np.array([1,2,3],dtype= np.float64)
arr1.dtype
```




    dtype('float64')



![数据类型](./数据类型.png)


```python
#转换数据类型(astype)
arr = np.array([1,2,3,4,5])
arr.dtype
```




    dtype('int32')




```python
float_arr = arr.astype(np.float64)
float_arr.dtype
```




    dtype('float64')



* NumPy 数组的运算


```python
%reset
```

    Once deleted, variables cannot be recovered. Proceed (y/[n])? y
    


```python
import numpy as np
arr = np.array([[1.,2.,3.],[4.,5.,6.]])
arr
```




    array([[ 1.,  2.,  3.],
           [ 4.,  5.,  6.]])




```python
arr * arr
```




    array([[  1.,   4.,   9.],
           [ 16.,  25.,  36.]])




```python
1 / arr
```




    array([[ 1.        ,  0.5       ,  0.33333333],
           [ 0.25      ,  0.2       ,  0.16666667]])




```python
arr2 = np.array([[0.,4.,1.],[7.,2.,12.]])
arr2
```




    array([[  0.,   4.,   1.],
           [  7.,   2.,  12.]])




```python
arr2 > arr
```




    array([[False,  True, False],
           [ True, False,  True]], dtype=bool)



* 索引与切片


```python
arr3 = np.arange(10)
arr3
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
arr3[5]
```




    5




```python
arr3[5:8]
```




    array([5, 6, 7])




```python
#赋值
arr3[5:8] = 12
arr3
```




    array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])



** 注意：**切片和复制修改其值会体现到原始数组中，可以用arr3[5:8].copy()来实现副本拷贝


```python
#二维数组索引
arr2d = np.array([[1,2,3],[4,5,6],[7,8,9]])
arr2d[2] #第三行全部元素
```




    array([7, 8, 9])




```python
arr2d[0][2]
```




    3




```python
arr2d[0,2]
```




    3




```python
arr2d[:2]
```




    array([[1, 2, 3],
           [4, 5, 6]])




```python
arr2d[:2, 1:]
```




    array([[2, 3],
           [5, 6]])



* 数组转置与轴对称


```python
%reset
```

    Once deleted, variables cannot be recovered. Proceed (y/[n])? y
    


```python
import numpy as np
arr = np.arange(15).reshape((3,5))
arr
```




    array([[ 0,  1,  2,  3,  4],
           [ 5,  6,  7,  8,  9],
           [10, 11, 12, 13, 14]])




```python
#转置
arr.T
```




    array([[ 0,  5, 10],
           [ 1,  6, 11],
           [ 2,  7, 12],
           [ 3,  8, 13],
           [ 4,  9, 14]])




```python
arr2 = np.random.randn(6,3)
arr2
```




    array([[-3.43036467, -0.46241331,  0.3983591 ],
           [ 0.83280362,  0.4921904 , -3.08139553],
           [-0.25576119, -0.79550342,  0.60009037],
           [ 0.37727655, -1.17041683,  2.06420893],
           [-0.98942851, -1.19513772, -1.33074557],
           [-0.85861892, -0.82553756, -0.18035998]])




```python
#矩阵相乘
np.dot(arr2.T,arr2)
```




    array([[ 14.38491026,   3.6493578 ,  -1.83587845],
           [  3.6493578 ,   4.56864514,  -2.85488048],
           [ -1.83587845,  -2.85488048,  16.07816882]])




```python
#高维数组转置
arr3 = np.arange(16).reshape(2,2,4)
arr3
```




    array([[[ 0,  1,  2,  3],
            [ 4,  5,  6,  7]],
    
           [[ 8,  9, 10, 11],
            [12, 13, 14, 15]]])




```python
arr3.transpose((1,0,2))
```




    array([[[ 0,  1,  2,  3],
            [ 8,  9, 10, 11]],
    
           [[ 4,  5,  6,  7],
            [12, 13, 14, 15]]])




```python
arr3.swapaxes(1,2)
```




    array([[[ 0,  4],
            [ 1,  5],
            [ 2,  6],
            [ 3,  7]],
    
           [[ 8, 12],
            [ 9, 13],
            [10, 14],
            [11, 15]]])



#### 4.2 通用函数：快速的元素级数组函数


```python
%reset
```

    Once deleted, variables cannot be recovered. Proceed (y/[n])? y
    


```python
import numpy as np
arr = np.arange(10)
arr
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
#开方
np.sqrt(arr)
```




    array([ 0.        ,  1.        ,  1.41421356,  1.73205081,  2.        ,
            2.23606798,  2.44948974,  2.64575131,  2.82842712,  3.        ])




```python
#e的n次方
np.exp(arr)
```




    array([  1.00000000e+00,   2.71828183e+00,   7.38905610e+00,
             2.00855369e+01,   5.45981500e+01,   1.48413159e+02,
             4.03428793e+02,   1.09663316e+03,   2.98095799e+03,
             8.10308393e+03])




```python
#x和y中元素级别最大的元素
x = np.random.randn(8)
y = np.random.randn(8)
np.maximum(x,y)
```




    array([ 0.81477055, -0.24858072,  0.73165334,  0.83770543,  1.24492386,
           -0.02460945, -0.56347625, -0.19928858])




```python
#返回整数和余数部分
arr2 = 5*x
remainder,whole_part = np.modf(arr2)
print(remainder,whole_part)
```

    [ 0.07385275 -0.24290362  0.65826671  0.18852715  0.2246193  -0.12304724
     -0.11196253 -0.99644288] [ 4. -1.  3.  4.  6. -0. -4. -0.]
    

![ufunc](./ufunc.png)
![ufunc](./ufunc2.png)

#### 4.3 利用数组进行数据处理(np.meshgrid)


```python
points = np.arange(-5, 5, 0.01)
xs,ys = np.meshgrid(points,points)
xs
```




    array([[-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
           [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
           [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
           ..., 
           [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
           [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
           [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99]])




```python
ys
```




    array([[-5.  , -5.  , -5.  , ..., -5.  , -5.  , -5.  ],
           [-4.99, -4.99, -4.99, ..., -4.99, -4.99, -4.99],
           [-4.98, -4.98, -4.98, ..., -4.98, -4.98, -4.98],
           ..., 
           [ 4.97,  4.97,  4.97, ...,  4.97,  4.97,  4.97],
           [ 4.98,  4.98,  4.98, ...,  4.98,  4.98,  4.98],
           [ 4.99,  4.99,  4.99, ...,  4.99,  4.99,  4.99]])




```python
z = np.sqrt(xs **2 + ys **2)
z
```




    array([[ 7.07106781,  7.06400028,  7.05693985, ...,  7.04988652,
             7.05693985,  7.06400028],
           [ 7.06400028,  7.05692568,  7.04985815, ...,  7.04279774,
             7.04985815,  7.05692568],
           [ 7.05693985,  7.04985815,  7.04278354, ...,  7.03571603,
             7.04278354,  7.04985815],
           ..., 
           [ 7.04988652,  7.04279774,  7.03571603, ...,  7.0286414 ,
             7.03571603,  7.04279774],
           [ 7.05693985,  7.04985815,  7.04278354, ...,  7.03571603,
             7.04278354,  7.04985815],
           [ 7.06400028,  7.05692568,  7.04985815, ...,  7.04279774,
             7.04985815,  7.05692568]])



* 将条件逻辑表述为数组运算(np.where)


```python
xarr = np.array([1.1, 1.2, 1.3,1.4, 1.5])
yarr = np.array([2.1, 2.2, 2.3,2.4, 2.5])
cond = np.array([True, False, True, True, False])
result = np.where(cond, xarr, yarr)
result
```




    array([ 1.1,  2.2,  1.3,  1.4,  2.5])




```python
arr = np.random.randn(4,4)
print(arr)
np.where(arr>0, 2, arr)
```

    [[-0.50587199 -1.46705105  0.48504689  0.31284142]
     [ 0.65690582 -1.4940051   1.19591911  0.57222938]
     [-1.1849105   0.48112454  0.97448023  0.2157983 ]
     [-0.78435076 -0.90014234 -1.76857748  0.44377872]]
    




    array([[-0.50587199, -1.46705105,  2.        ,  2.        ],
           [ 2.        , -1.4940051 ,  2.        ,  2.        ],
           [-1.1849105 ,  2.        ,  2.        ,  2.        ],
           [-0.78435076, -0.90014234, -1.76857748,  2.        ]])



* 数学统计方法（np.sum, np.mean等）


```python
arr = np.random.randn(5, 4)
print(arr)
np.mean(arr)
```

    [[ 0.14379612 -1.05127054 -0.28953247 -0.0304498 ]
     [ 0.20345879 -0.33494752  0.80777876  0.12869618]
     [-0.42512754  0.86392891  1.1917091  -0.23176883]
     [ 0.19436993 -0.0904441   0.19615493  0.04061789]
     [ 1.04491744 -0.88491519 -2.23292026  0.20562168]]
    




    -0.027516325997896263




```python
np.sum(arr)
```




    -0.55032651995792525




```python
np.sum(arr, axis=1) #计算行和 
```




    array([-1.22745669,  0.80498621,  1.39874164,  0.34069865, -1.86729633])




```python
np.sum(arr, axis=0) #计算列和
```




    array([ 1.16141474, -1.49764844, -0.32680993,  0.11271711])




```python
arr1 = np.arange(8)
print(arr1)
arr1.cumsum() #累加函数 
```

    [0 1 2 3 4 5 6 7]
    




    array([ 0,  1,  3,  6, 10, 15, 21, 28], dtype=int32)




```python
arr1.cumprod() #累乘函数
```




    array([0, 0, 0, 0, 0, 0, 0, 0], dtype=int32)



* 用于布尔型数组的方法  
.any()检测测试数组中是否存在一个或多个True  
.all()检测数组中是否所有值都是True  

* 排序（.sort函数）  
sort(1)对行排序  
sort(0）对列排序

* 唯一化以及它的集合逻辑  

![数组集合运算](./集合运算.png)

#### 用于数组的文件输入输出

np.save和np.load是读写磁盘数组数据的两个主要函数。默认情况下，数组是以未压缩的原始⼆进制格式保存在扩展名为.npy的⽂件中的

#### 4.5 线性代数

![](./线性代数.png)

#### 4.6 伪随机数的生成


```python
samples = np.random.normal(size= (4,4))
samples
```




    array([[-0.06593198,  0.44394349, -0.07268544,  0.15759318],
           [-0.39161139, -1.60831927, -0.2510698 ,  1.66185673],
           [-0.93231456,  0.21819627,  0.41138718,  0.47970729],
           [ 0.42257601, -1.43952497,  0.02902197,  2.05305852]])



![](./随机数.png)
